apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: prod-security-netpol
spec:
  # 1. Target: Apply this policy to pods with label 'env: production'
  podSelector:
    matchLabels:
      env: production
      environment: production

  # 2. Define Policy Types: We are controlling both Ingress and Egress
  policyTypes:
  - Ingress
  - Egress

  # 3. Ingress Rules: Allow traffic ONLY from pods with label 'env: security'
  ingress:
  - from:
    - podSelector:
        matchLabels:
          env: security

  # 4. Egress Rules: Allow traffic ONLY to the specific IP 8.8.8.8
  egress:
  - to:
    - ipBlock:
        cidr: 8.8.8.8/32

---

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-all-traffic
  namespace: default  # Change this to the namespace you want to open up
spec:
  # 1. Select ALL pods in this namespace (Empty selector = Wildcard)
  podSelector: {}

  # 2. Apply to both incoming and outgoing traffic
  policyTypes:
  - Ingress
  - Egress

  # 3. Allow ALL Ingress (Empty rule list item = Allow everything)
  ingress:
  - {}

  # 4. Allow ALL Egress (Empty rule list item = Allow everything)
  egress:
  - {}

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: default
spec:
  # 1. Select ALL pods in this namespace
  podSelector: {}

  # 2. Apply to both traffic directions
  policyTypes:
  - Ingress
  - Egress

  # 3. By OMITTING the 'ingress' and 'egress' sections below,
  #    we tell Kubernetes: "Enforce the policy type, but allow NOTHING."

---

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-ingress
  namespace: default
spec:
  # 1. Select ALL pods in this namespace
  podSelector: {}

  # 2. Apply ONLY to incoming traffic
  policyTypes:
  - Ingress

  # 3. By OMITTING the 'ingress' section below,
  #    we tell Kubernetes: "Enforce Ingress policy, but allow NOTHING."
  #    (Egress is unrestricted because it is not listed in policyTypes)

---

#default-deny-egress.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-egress
  namespace: default
spec:
  # 1. Select ALL pods in this namespace
  podSelector: {}

  # 2. Apply ONLY to outgoing traffic
  policyTypes:
  - Egress

  # 3. By OMITTING the 'egress' section below,
  #    we tell Kubernetes: "Enforce Egress policy, but allow NOTHING."
  #    (Ingress is unrestricted because it is not listed in policyTypes)


---
apiVersion: "cilium.io/v2"
kind: CiliumNetworkPolicy
metadata:
  name: default
  namespace: metadata-access
spec:
  endpointSelector:
    matchLabels: {}
  
  # ALLOW section
  egress:
    - toCIDRSet:
        - cidr: 0.0.0.0/0  # Allow the whole world (including .21)
    - toEndpoints:
        - matchLabels:
            "k8s:io.kubernetes.pod.namespace": metadata-access
    - toEndpoints:
        - matchLabels:
            "k8s:io.kubernetes.pod.namespace": kube-system

  # DENY section (Takes precedence)
  egressDeny:
    - toCIDRSet:
        - cidr: 192.168.100.21/32
      toPorts:
        - ports:
            - port: "9055"
              protocol: TCP
---
- rule: Custom Rule 1
  desc: Detects any container access to files or directories with prefix /etc/kubernetes
  condition: >
    container.id != host and
    fd.name startswith /etc/kubernetes
  output: "custom_rule_1 file=%fd.name container=%container.id"
  priority: WARNING

  ---
- rule: Custom Rule 2
  desc: Detects any container making network connections to IP 192.168.100.21 on port 9055
  condition: >
    container.id != host and
    net.dip == 192.168.100.21 and
    net.dport == 9055
  output: "custom_rule_2 dip=%net.dip dport=%net.dport container=%container.id"
  priority: WARNING

  ---